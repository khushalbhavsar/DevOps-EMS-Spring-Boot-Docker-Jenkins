stages:
  - validate
  - build
  - test
  - quality
  - docker
  - deploy

variables:
  MAVEN_CLI_OPTS: "-B -e -V"
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"
  MAVEN_OPTS: "-Dmaven.repo.local=$CI_PROJECT_DIR/.m2/repository"

cache:
  paths:
    - .m2/repository/
  key: "$CI_JOB_NAME"

# Pre-build validation
validate:
  image: maven:3.9.3-eclipse-temurin-17
  stage: validate
  script:
    - mvn $MAVEN_CLI_OPTS validate
  only:
    - merge_requests
    - main
    - develop

# Build the application
build:
  image: maven:3.9.3-eclipse-temurin-17
  stage: build
  script:
    - mvn $MAVEN_CLI_OPTS clean compile
    - mvn $MAVEN_CLI_OPTS package -DskipTests
  artifacts:
    paths:
      - target/*.jar
    expire_in: 1 hour
    reports:
      junit: target/surefire-reports/TEST-*.xml
  only:
    - merge_requests
    - main
    - develop

# Run unit tests
test:
  image: maven:3.9.3-eclipse-temurin-17
  stage: test
  script:
    - mvn $MAVEN_CLI_OPTS test
  coverage: '/Total.*?([0-9]{1,3})%/'
  artifacts:
    when: always
    reports:
      junit: target/surefire-reports/TEST-*.xml
      coverage_report:
        coverage_format: cobertura
        path: target/site/cobertura/coverage.xml
    paths:
      - target/site/jacoco/
    expire_in: 30 days
  only:
    - merge_requests
    - main
    - develop

# Code quality analysis (optional - requires SonarQube)
code_quality:
  image: maven:3.9.3-eclipse-temurin-17
  stage: quality
  script:
    - echo "Code quality checks would go here"
    - mvn $MAVEN_CLI_OPTS checkstyle:check || true
  allow_failure: true
  only:
    - merge_requests
    - main
    - develop

# Build and push Docker image
docker-build-push:
  image: docker:24.0.0
  services:
    - docker:24.0.0-dind
  stage: docker
  variables:
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_CERTDIR: "/certs"
  before_script:
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
  script:
    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA .
    - docker build -t $CI_REGISTRY_IMAGE:latest .
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA
    - docker push $CI_REGISTRY_IMAGE:latest
  after_script:
    - docker logout $CI_REGISTRY
  only:
    - main
    - develop

# Deploy to development environment
deploy_dev:
  image: alpine:latest
  stage: deploy
  variables:
    ENVIRONMENT: "development"
  before_script:
    - apk add --no-cache curl
  script:
    - echo "Deploying to development environment"
    - echo "Image: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA"
    # Add your deployment commands here
    # Example: kubectl set image deployment/employee-mgmt employee-mgmt=$CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA
  environment:
    name: development
    url: https://dev-employee-mgmt.yourdomain.com
  only:
    - develop
  when: manual

# Deploy to staging environment
deploy_staging:
  image: alpine:latest
  stage: deploy
  variables:
    ENVIRONMENT: "staging"
  before_script:
    - apk add --no-cache curl
  script:
    - echo "Deploying to staging environment"
    - echo "Image: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA"
    # Add your deployment commands here
  environment:
    name: staging
    url: https://staging-employee-mgmt.yourdomain.com
  only:
    - main
  when: manual

# Deploy to production environment
deploy_production:
  image: alpine:latest
  stage: deploy
  variables:
    ENVIRONMENT: "production"
  before_script:
    - apk add --no-cache curl
  script:
    - echo "Deploying to production environment"
    - echo "Image: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA"
    # Add your deployment commands here
  environment:
    name: production
    url: https://employee-mgmt.yourdomain.com
  only:
    - main
  when: manual
  allow_failure: false